<!DOCTYPE html>

<html lang="fr">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Marsdown: un parser markdown vers html</title>

    <link href="https://unpkg.com/tailwindcss@^1.0/dist/base.min.css" rel="stylesheet" />

    <link rel="stylesheet" href="../../css/articles.css">

</head>

<body>

    <articletitle>Marsdown: un parser markdown vers html</articletitle>

    <article class="articlewrapper">


        <p>Apres avoir ecrit un article sur ce blog, je me suis rendu compte a quel point il etait long et peu optimise
            d'ecrire tout l'html a la main et que ce serait plus pratique avec un langage comme le markdown, etant donne
            que je n'ai pas besoin d'elements compliques.</p>
        <p>Ce site etant heberge via GitHub pages, je ne pouvais pas installer de parser markdown vu que l'on ne peut
            pas utiliser de serveur comme apache ou nginx.</p>
        <p>J'ai donc decide d'ecrire moi meme un outil pour transformer du markdown en html adapte pour cette page.</p>
        <h1 id="comment-?">Comment ?</h1>
        <h2 id="le-lexer">Le Lexer</h2>
        <p>Pour faire ceci, j'ai decide d'utiliser le langage de programmation rust.</p>
        <p>J'ai commence par ecrire un lexer, outil pour "decouper" la source en tokens, tokens portant chacun un type
            et un contenu.</p>
        <p>Le code de lexer pour les images : </p>
        <pre>
'!' =&rsaquo; {
    if self.next_is('[') {
        self.advance();
        let mut alt = String::new();

                    while !self.next_is(']') {
                        alt.push(self.advance());
                    }
                    self.advance();
                    if self.next_is('(') {
                        let mut link = String::new();
                        self.advance();
                        while !self.next_is(')') {
                            link.push(self.advance());
                        }
                        self.advance();
                        self.add_token(TokenType::Img(alt, link));
                    } else {
                        self.add_token(TokenType::Char('!'));
                        self.add_token(TokenType::Char('['));
                        let chars: Vec&lsaquo;char&rsaquo; = alt.chars().collect();
                        for c in chars {
                            self.add_token(TokenType::Char(c));
                        }
                        self.add_token(TokenType::Char(']'));
                    }
                } else {
                    self.add_token(TokenType::Char('!'));
                }
            }

</pre>
        <p>Il va decouper caractere par caractere en verifiant si ils correspondent a des delimiteurs pour l'objet,
            puis, grace aux caracteres obtenus, il va les decouper en tokens correspondant a ce qu'ils representent.</p>
        <p>Par exemple <code>![alt](link)\n#Title</code> donnera :</p>
        <pre>
TokenType::Img("alt", "link")
TokenType::H1("Title")
</pre>
        <h2 id="le-parser">Le parser</h2>
        <p>Ensuite, j'ai ecrit un parser, qui va prendre en entree des tokens et ressortir du code html viable.</p>
        <p>Par exemple, le code de parser pour les liens :</p>
        <pre>
match tok.toktype {
    TokenType::Link(ref alt, ref link) =&rsaquo; {
        content.push_str(format!("&lsaquo;a href=\"{}\"&rsaquo;{}&lsaquo;/a&rsaquo;\n", link, alt).as_str())
    }
}
</pre>
        <h1 id="disclaimer">Disclaimer</h1>
        <p>Cet outil ne supporte pas l'utf-8, ce qui implique de devoir retoucher l'html a la main apres
            transformation.</p>
        <h1 id="conclusion">Conclusion</h1>
        <a href="https://github.com/Wafelack/marsdown">Le repo de cet outil</a><br>
        <a href="https://craftinginterpreters.com/">En savoir plus sur les parser et lexers</a><br>
        <p>Merci de m'avoir lu, et bonne journee/soiree.</p>

    </article>
    <p>Made with <a href="https://github.com/Wafelack/marsdown">marsdown</a>

</body>

</html>